Внедрение зависимостей
(Dependency Injection)

	По мере того, как наши программы увеличиваются в размерах, части приложения должны взаимодействовать с другими модулями. Когда модуль A требует запуска модуля B, мы говорим, что B является зависимостью модуля A.
	Один из наиболее распространенных способов получить доступ к зависимостям — просто импортировать файл. Например, в этом гипотетическом модуле мы могли бы сделать следующее:

	// в A.ts
	import { B } from"B"; // !
	B.foo(); // используя B

	Во многих случаях достаточно просто импортировать код, но в других случаях нам нужно обеспечить зависимости более изощренным способом. Например, мы можем захотеть:
    • заменить реализацию B на MockB во время тестирования
    • совместно использовать один экземпляр класса B во всем нашем приложении (например, шаблон Singleton)
    • создать новый экземпляр класса B каждый раз, когда он используется (например, шаблон Factory).
	Внедрение зависимостей может решить эти проблемы. Внедрение зависимостей (DI) — это система, позволяющая сделать части нашей программы доступными для других частей программы. Один из способов представить «инжектор» — это замена нового оператора. Термин «внедрение зависимостей» используется для описания как шаблона проектирования (используемого во многих различных средах), так и конкретной реализации DI, встроенной в Angular.
	Основное преимущество внедрения зависимостей заключается в том, что клиентскому компоненту не нужно знать, как создавать зависимости. Все, что нужно клиентскому компоненту, — это знать, как взаимодействовать с этими зависимостями. Все это очень абстрактно, так что давайте углубимся в код.

	PriceService

	Давайте представим, что мы создаем магазин, в котором есть товары, и нам нужно рассчитать окончательную цену этого товара после уплаты налога с продаж. Чтобы рассчитать полную цену этого продукта, мы используем службу PriceService, которая принимает в качестве входных данных:
    • базовую цену продукта;
    • штат, в котором мы его продаем,
а затем возвращает окончательную цену продукта плюс налог:

YouTubeClient
	Давайте попробуем создать приложение YouTubeСдшуте, котрое предоставляет возможность поиска и отображения результатов поиска в виде скриншотов видео, а также их описание и ссылок на каждое видео.
	Вот скриншот того, что происходит, когда мы ввеведем “cats playing ipads”:
	
	Для этого приложения нам необходимы:
1. Объект SearchResult, который будет содержать данные, которые мы хотим получить из каждого результата.
2. Служба поиска YouTube, которая будет управлять запросом API к YouTube и преобразовывать результаты в массив SearchResult[].
3. Компонент SearchBox, который будет вызывать сервис YouTube в качестве usertypes
4. SearchResultComponent, который будет отображать определенный компонент поискаSearchResult
5. YouTubeSearchComponent, который будет инкапсулировать все наше приложение для поиска YouTube и отображать список результатов.

	Давайте рассмотрим каждую часть по отдельности. 

SearchResult

	Для начала давайте начнем с написания базового класса модели SearchResult.

 	(search-result.model.ts)

export class SearchResult {
    id:string;
    title:string;
    description:string;
    thumbnailUrl:string;
    videoUrl:string;
    
    constructor(obj?:any) {
        this.id = obj && obj.id || null;
        this.title = obj && obj.title || null;
        this.description = obj && obj.description ||null;
        this.thumbnailUrl = obj && obj.thumbnailUrl || null;
        this.videoUrl = obj && obj.videoUrl || `https://www.youtube.com/watch?v=${this.id}`;
    }
}

	Шаблон использования obj?: any позволяет имитировать ключевые параметры запроса. Идея заключается в том, что мы можем создать newSearchResult и просто передать объект, содержащий ключи, которые мы хотим указать. Единственное, на что здесь следует обратить внимание, это то, что мы создаем URL-адрес видео, используя жестко заданный формат URL-адреса. 

	YouTubeSearchService
	
	В этом примере мы будем использовать API YouTube для поиска. Чтобы использовать этот API, вам нужен ключ API. Я включил APIkey в пример кода, который вы можете использовать. Однако к тому времени, когда вы это прочитаете, вы можете обнаружить, что ключ устарел. В этом случае вам потребуется получить собственный ключ. 
	Для настройки API мы будем использовать две константы для задания ключа и URL-адреса.

const YOUTUBE_API_KEY: string = "XXX_YOUR_KEY_HERE_XXX";
const YOUTUBE_API_URL: string = "https://www.googleapis.com/youtube/v3/search";

	Нам необходимо сделать эти константы внедряемыми. Почему мы должны внедрять эти константы вместо того, чтобы просто использовать их обычным способом? Внедряя эти значения, мы получаем гораздо больше гибкости в отношении их значений в будущем. Чтобы сделать эти значения доступными для внедрения, мы используем синтаксис {provide: ... , useValue:... } следующим образом:
	Для внедрения зависимостей в наше приложение, нам нужно поместить ихо в провайдеры для нашего NgModule. Поскольку мы экспортируем youTubeServiceInjectable, мы должны указать это в главном модуле app.module.ts.

 
	



